import { describe, test, expect, beforeEach, vi } from "vitest";
import {
  applyExclusionConfig,
  PRESETS,
  saveConfig,
  loadConfig,
  DEFAULT_CONFIG,
} from "../../src/core/config";
import { Line, Token } from "../../src/types/snippet";
import { TypingMode } from "../../src/types/config";

describe("Config: Token Filtering Logic", () => {
  /**
   * Helper function to create a minimal Line structure for testing
   */
  function createTestLine(tokens: Token[]): Line {
    return {
      line_number: 0,
      indent_level: 0,
      display_tokens: tokens,
      typing_sequence: "", // Will be regenerated by applyExclusionConfig
      char_map: {},
    };
  }

  describe("Whitespace Handling", () => {
    test("pure whitespace tokens are never typeable", () => {
      const line = createTestLine([
        {
          text: " ",
          type: "whitespace",
          typeable: true,
          base_typeable: false,
          start_col: 0,
          end_col: 1,
          categories: [],
        },
      ]);

      const result = applyExclusionConfig(line, "full");
      expect(result.display_tokens[0].typeable).toBe(false);
      expect(result.typing_sequence).toBe("");
    });

    test("jsx_text_whitespace tokens are never typeable", () => {
      const line = createTestLine([
        {
          text: "Item name:",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 10,
          categories: [],
        },
        {
          text: " ",
          type: "jsx_text_whitespace",
          typeable: false,
          base_typeable: false,
          start_col: 10,
          end_col: 11,
          categories: [],
        },
      ]);

      const result = applyExclusionConfig(line, "full");
      expect(result.display_tokens[1].typeable).toBe(false);
      expect(result.typing_sequence).toBe("Item name:");
    });

    test("spaces within jsx_text content remain typeable", () => {
      const line = createTestLine([
        {
          text: "Loading item...",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 15,
          categories: [],
        },
      ]);

      const result = applyExclusionConfig(line, "full");
      expect(result.display_tokens[0].typeable).toBe(true);
      expect(result.typing_sequence).toBe("Loading item...");
    });
  });

  describe("JSX Tag Name Handling - THE CRITICAL BUG", () => {
    test("MINIMAL MODE: JSX tag names should be excluded (currently FAILING)", () => {
      // Line 18: if (loading) return <p>Loading item...</p>;
      const line = createTestLine([
        {
          text: "if",
          type: "if",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 2,
          categories: [],
        },
        {
          text: "(",
          type: "(",
          typeable: true,
          base_typeable: true,
          start_col: 2,
          end_col: 3,
          categories: ["parenthesis"],
        },
        {
          text: "loading",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 3,
          end_col: 10,
          categories: [],
        },
        {
          text: ")",
          type: ")",
          typeable: true,
          base_typeable: true,
          start_col: 10,
          end_col: 11,
          categories: ["parenthesis"],
        },
        {
          text: "return",
          type: "return",
          typeable: true,
          base_typeable: true,
          start_col: 12,
          end_col: 18,
          categories: [],
        },
        {
          text: "<",
          type: "<",
          typeable: true,
          base_typeable: true,
          start_col: 19,
          end_col: 20,
          categories: ["angle_bracket"],
        },
        {
          text: "p",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 20,
          end_col: 21,
          categories: [], // ← NO CATEGORY! This is the problem
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 21,
          end_col: 22,
          categories: ["angle_bracket"],
        },
        {
          text: "Loading item...",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 22,
          end_col: 37,
          categories: [],
        },
        {
          text: "</",
          type: "</",
          typeable: true,
          base_typeable: true,
          start_col: 37,
          end_col: 39,
          categories: ["angle_bracket"],
        },
        {
          text: "p",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 39,
          end_col: 40,
          categories: [], // ← NO CATEGORY! This is the problem
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 40,
          end_col: 41,
          categories: ["angle_bracket"],
        },
        {
          text: ";",
          type: ";",
          typeable: true,
          base_typeable: true,
          start_col: 41,
          end_col: 42,
          categories: ["punctuation"],
        },
      ]);

      const result = applyExclusionConfig(line, "minimal");

      // EXPECTED BEHAVIOR:
      // - Angle brackets excluded ✓
      // - JSX tag names ("p") should be excluded ✗ (currently failing)
      // - JSX text content included ✓
      // - Keywords included ✓
      // - Regular identifiers included ✓

      expect(result.display_tokens[5].typeable).toBe(false); // <
      expect(result.display_tokens[6].typeable).toBe(false); // p ← SHOULD BE FALSE
      expect(result.display_tokens[7].typeable).toBe(false); // >
      expect(result.display_tokens[8].typeable).toBe(true); // Loading item...
      expect(result.display_tokens[9].typeable).toBe(false); // </
      expect(result.display_tokens[10].typeable).toBe(false); // p ← SHOULD BE FALSE
      expect(result.display_tokens[11].typeable).toBe(false); // >

      // Expected typing sequence (without 'p' tags)
      expect(result.typing_sequence).toBe("ifloadingreturnLoading item...");

      // NOT the current broken sequence:
      expect(result.typing_sequence).not.toBe(
        "ifloadingreturnpLoading item...p"
      );
    });

    test("STANDARD MODE: JSX tag names should be excluded (currently FAILING)", () => {
      const line = createTestLine([
        {
          text: "<",
          type: "<",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 1,
          categories: ["angle_bracket"],
        },
        {
          text: "div",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 1,
          end_col: 4,
          categories: [],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 4,
          end_col: 5,
          categories: ["angle_bracket"],
        },
        {
          text: "Hello",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 5,
          end_col: 10,
          categories: [],
        },
        {
          text: "</",
          type: "</",
          typeable: true,
          base_typeable: true,
          start_col: 10,
          end_col: 12,
          categories: ["angle_bracket"],
        },
        {
          text: "div",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 12,
          end_col: 15,
          categories: [],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 15,
          end_col: 16,
          categories: ["angle_bracket"],
        },
      ]);

      const result = applyExclusionConfig(line, "standard");

      expect(result.display_tokens[0].typeable).toBe(false); // <
      expect(result.display_tokens[1].typeable).toBe(false); // div ← SHOULD BE FALSE
      expect(result.display_tokens[2].typeable).toBe(false); // >
      expect(result.display_tokens[3].typeable).toBe(true); // Hello
      expect(result.display_tokens[4].typeable).toBe(false); // </
      expect(result.display_tokens[5].typeable).toBe(false); // div ← SHOULD BE FALSE
      expect(result.display_tokens[6].typeable).toBe(false); // >

      expect(result.typing_sequence).toBe("Hello");
      expect(result.typing_sequence).not.toBe("divHellodiv");
    });

    test("FULL MODE: JSX tag names SHOULD be included", () => {
      const line = createTestLine([
        {
          text: "<",
          type: "<",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 1,
          categories: ["angle_bracket"],
        },
        {
          text: "span",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 1,
          end_col: 5,
          categories: [],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 5,
          end_col: 6,
          categories: ["angle_bracket"],
        },
        {
          text: "Text",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 6,
          end_col: 10,
          categories: [],
        },
        {
          text: "</",
          type: "</",
          typeable: true,
          base_typeable: true,
          start_col: 10,
          end_col: 12,
          categories: ["angle_bracket"],
        },
        {
          text: "span",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 12,
          end_col: 16,
          categories: [],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 16,
          end_col: 17,
          categories: ["angle_bracket"],
        },
      ]);

      const result = applyExclusionConfig(line, "full");

      // In FULL mode, everything is typeable (except comments)
      expect(result.display_tokens[0].typeable).toBe(true); // <
      expect(result.display_tokens[1].typeable).toBe(true); // span
      expect(result.display_tokens[2].typeable).toBe(true); // >
      expect(result.display_tokens[3].typeable).toBe(true); // Text
      expect(result.display_tokens[4].typeable).toBe(true); // </
      expect(result.display_tokens[5].typeable).toBe(true); // span
      expect(result.display_tokens[6].typeable).toBe(true); // >

      expect(result.typing_sequence).toBe("<span>Text</span>");
    });

    test("Complex JSX: multiple tags and attributes", () => {
      console.log("\n=== COMPLEX JSX TEST START ===");
      
      const line = createTestLine([
        {
          text: "<",
          type: "<",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 1,
          categories: ["angle_bracket"],
        },
        {
          text: "button",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 1,
          end_col: 7,
          categories: [],
        },
        {
          text: "onClick",
          type: "property_identifier",
          typeable: true,
          base_typeable: true,
          start_col: 8,
          end_col: 15,
          categories: [],
        },
        {
          text: "=",
          type: "=",
          typeable: true,
          base_typeable: true,
          start_col: 15,
          end_col: 16,
          categories: ["operator"],
        },
        {
          text: "{",
          type: "{",
          typeable: true,
          base_typeable: true,
          start_col: 16,
          end_col: 17,
          categories: ["curly_brace"],
        },
        {
          text: "handleClick",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 17,
          end_col: 28,
          categories: [],
        },
        {
          text: "}",
          type: "}",
          typeable: true,
          base_typeable: true,
          start_col: 28,
          end_col: 29,
          categories: ["curly_brace"],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 29,
          end_col: 30,
          categories: ["angle_bracket"],
        },
        {
          text: "Click",
          type: "jsx_text",
          typeable: true,
          base_typeable: true,
          start_col: 30,
          end_col: 35,
          categories: [],
        },
        {
          text: "</",
          type: "</",
          typeable: true,
          base_typeable: true,
          start_col: 35,
          end_col: 37,
          categories: ["angle_bracket"],
        },
        {
          text: "button",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 37,
          end_col: 43,
          categories: [],
        },
        {
          text: ">",
          type: ">",
          typeable: true,
          base_typeable: true,
          start_col: 43,
          end_col: 44,
          categories: ["angle_bracket"],
        },
      ]);

      console.log("Input tokens:");
      line.display_tokens.forEach((token, idx) => {
        console.log(`  [${idx}] "${token.text}" | type: ${token.type} | prev: "${line.display_tokens[idx-1]?.text || 'none'}" | next: "${line.display_tokens[idx+1]?.text || 'none'}"`);
      });

      const result = applyExclusionConfig(line, "minimal");

      console.log("\nAfter filtering:");
      result.display_tokens.forEach((token, idx) => {
        console.log(`  [${idx}] "${token.text}" | typeable: ${token.typeable}`);
      });
      console.log(`\nTyping sequence: "${result.typing_sequence}"`);
      console.log("=== COMPLEX JSX TEST END ===\n");

      // Tag names should be excluded in minimal mode
      expect(result.display_tokens[1].typeable).toBe(false); // button (opening)
      expect(result.display_tokens[10].typeable).toBe(false); // button (closing)

      // Regular identifiers (onClick, handleClick) should be included
      expect(result.display_tokens[2].typeable).toBe(true); // onClick
      expect(result.display_tokens[5].typeable).toBe(true); // handleClick

      // JSX text should be included
      expect(result.display_tokens[8].typeable).toBe(true); // Click

      // Should NOT have tag names in sequence
      expect(result.typing_sequence).not.toContain("button");
      expect(result.typing_sequence).toContain("onClick");
      expect(result.typing_sequence).toContain("handleClick");
      expect(result.typing_sequence).toContain("Click");
    });
  });

  describe("Mode-Specific Token Filtering", () => {
    test("MINIMAL mode: excludes operators, parentheses, braces", () => {
      const line = createTestLine([
        {
          text: "const",
          type: "const",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 5,
          categories: [],
        },
        {
          text: "x",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 6,
          end_col: 7,
          categories: [],
        },
        {
          text: "=",
          type: "=",
          typeable: true,
          base_typeable: true,
          start_col: 8,
          end_col: 9,
          categories: ["operator"],
        },
        {
          text: "5",
          type: "number",
          typeable: true,
          base_typeable: true,
          start_col: 10,
          end_col: 11,
          categories: [],
        },
      ]);

      const result = applyExclusionConfig(line, "minimal");

      expect(result.display_tokens[0].typeable).toBe(true); // const
      expect(result.display_tokens[1].typeable).toBe(true); // x
      expect(result.display_tokens[2].typeable).toBe(false); // = (operator)
      expect(result.display_tokens[3].typeable).toBe(true); // 5

      expect(result.typing_sequence).toBe("constx5");
    });

    test("STANDARD mode: includes parentheses via includeSpecific", () => {
      const line = createTestLine([
        {
          text: "function",
          type: "function",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 8,
          categories: [],
        },
        {
          text: "test",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 9,
          end_col: 13,
          categories: [],
        },
        {
          text: "(",
          type: "(",
          typeable: true,
          base_typeable: true,
          start_col: 13,
          end_col: 14,
          categories: ["parenthesis"],
        },
        {
          text: ")",
          type: ")",
          typeable: true,
          base_typeable: true,
          start_col: 14,
          end_col: 15,
          categories: ["parenthesis"],
        },
      ]);

      const minimalResult = applyExclusionConfig(line, "minimal");
      const standardResult = applyExclusionConfig(line, "standard");

      // Minimal excludes parentheses
      expect(minimalResult.display_tokens[2].typeable).toBe(false);
      expect(minimalResult.display_tokens[3].typeable).toBe(false);
      expect(minimalResult.typing_sequence).toBe("functiontest");

      // Standard includes them via includeSpecific
      expect(standardResult.display_tokens[2].typeable).toBe(true);
      expect(standardResult.display_tokens[3].typeable).toBe(true);
      expect(standardResult.typing_sequence).toBe("functiontest()");
    });

    test("FULL mode: includes everything except comments", () => {
      const line = createTestLine([
        {
          text: "const",
          type: "const",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 5,
          categories: [],
        },
        {
          text: "[",
          type: "[",
          typeable: true,
          base_typeable: true,
          start_col: 6,
          end_col: 7,
          categories: ["square_bracket"],
        },
        {
          text: "x",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 7,
          end_col: 8,
          categories: [],
        },
        {
          text: ",",
          type: ",",
          typeable: true,
          base_typeable: true,
          start_col: 8,
          end_col: 9,
          categories: ["punctuation"],
        },
        {
          text: "y",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 10,
          end_col: 11,
          categories: [],
        },
        {
          text: "]",
          type: "]",
          typeable: true,
          base_typeable: true,
          start_col: 11,
          end_col: 12,
          categories: ["square_bracket"],
        },
        {
          text: "=",
          type: "=",
          typeable: true,
          base_typeable: true,
          start_col: 13,
          end_col: 14,
          categories: ["operator"],
        },
        {
          text: "[",
          type: "[",
          typeable: true,
          base_typeable: true,
          start_col: 15,
          end_col: 16,
          categories: ["square_bracket"],
        },
        {
          text: "1",
          type: "number",
          typeable: true,
          base_typeable: true,
          start_col: 16,
          end_col: 17,
          categories: [],
        },
        {
          text: ",",
          type: ",",
          typeable: true,
          base_typeable: true,
          start_col: 17,
          end_col: 18,
          categories: ["punctuation"],
        },
        {
          text: "2",
          type: "number",
          typeable: true,
          base_typeable: true,
          start_col: 19,
          end_col: 20,
          categories: [],
        },
        {
          text: "]",
          type: "]",
          typeable: true,
          base_typeable: true,
          start_col: 20,
          end_col: 21,
          categories: ["square_bracket"],
        },
      ]);

      const result = applyExclusionConfig(line, "full");

      // Everything should be typeable in full mode
      result.display_tokens.forEach((token) => {
        expect(token.typeable).toBe(true);
      });

      expect(result.typing_sequence).toBe("const[x,y]=[1,2]");
    });
  });

  describe("Comments", () => {
    test("comments are excluded in all modes", () => {
      const line = createTestLine([
        {
          text: "// This is a comment",
          type: "comment",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 20,
          categories: ["comment"],
        },
      ]);

      ["minimal", "standard", "full"].forEach((mode) => {
        const result = applyExclusionConfig(line, mode as TypingMode);
        expect(result.display_tokens[0].typeable).toBe(false);
        expect(result.typing_sequence).toBe("");
      });
    });
  });

  describe("Typing Sequence Generation", () => {
    test("regenerates typing sequence correctly", () => {
      const line = createTestLine([
        {
          text: "hello",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 5,
          categories: [],
        },
        {
          text: "(",
          type: "(",
          typeable: true,
          base_typeable: true,
          start_col: 5,
          end_col: 6,
          categories: ["parenthesis"],
        },
        {
          text: "world",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 6,
          end_col: 11,
          categories: [],
        },
        {
          text: ")",
          type: ")",
          typeable: true,
          base_typeable: true,
          start_col: 11,
          end_col: 12,
          categories: ["parenthesis"],
        },
      ]);

      const minimalResult = applyExclusionConfig(line, "minimal");
      expect(minimalResult.typing_sequence).toBe("helloworld");

      const standardResult = applyExclusionConfig(line, "standard");
      expect(standardResult.typing_sequence).toBe("hello(world)");
    });

    test("char_map maps to correct token indices", () => {
      const line = createTestLine([
        {
          text: "abc",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 3,
          categories: [],
        },
        {
          text: "(",
          type: "(",
          typeable: true,
          base_typeable: true,
          start_col: 3,
          end_col: 4,
          categories: ["parenthesis"],
        },
        {
          text: "def",
          type: "identifier",
          typeable: true,
          base_typeable: true,
          start_col: 4,
          end_col: 7,
          categories: [],
        },
        {
          text: ")",
          type: ")",
          typeable: true,
          base_typeable: true,
          start_col: 7,
          end_col: 8,
          categories: ["parenthesis"],
        },
      ]);

      const result = applyExclusionConfig(line, "minimal");

      // Typing sequence: "abcdef" (parentheses excluded)
      // Char 0-2 → token 0 (abc)
      // Char 3-5 → token 2 (def) - note: token 1 is skipped
      expect(result.char_map["0"].token_idx).toBe(0);
      expect(result.char_map["1"].token_idx).toBe(0);
      expect(result.char_map["2"].token_idx).toBe(0);
      expect(result.char_map["3"].token_idx).toBe(2);
      expect(result.char_map["4"].token_idx).toBe(2);
      expect(result.char_map["5"].token_idx).toBe(2);
    });
  });

  describe("localStorage Integration", () => {
    beforeEach(() => {
      // Clear localStorage before each test
      global.localStorage.clear();
    });

    test("saveConfig stores configuration correctly", () => {
      const config = {
        preset: "minimal" as const,
        language: "tsx" as const,
      };

      saveConfig(config);

      const stored = JSON.parse(localStorage.getItem("treetype_config")!);
      expect(stored).toEqual(config);
    });

    test("loadConfig retrieves saved configuration", () => {
      const config = {
        preset: "standard" as const,
        language: "python" as const,
      };

      localStorage.setItem("treetype_config", JSON.stringify(config));

      const loaded = loadConfig();
      expect(loaded).toEqual(config);
    });

    test("loadConfig returns DEFAULT_CONFIG when nothing saved", () => {
      const loaded = loadConfig();
      expect(loaded).toEqual(DEFAULT_CONFIG);
    });
  });

  describe("Edge Cases", () => {
    test("empty token array", () => {
      const line = createTestLine([]);

      const result = applyExclusionConfig(line, "minimal");
      expect(result.typing_sequence).toBe("");
      expect(Object.keys(result.char_map).length).toBe(0);
    });

    test("all tokens excluded", () => {
      const line = createTestLine([
        {
          text: "(",
          type: "(",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 1,
          categories: ["parenthesis"],
        },
        {
          text: ")",
          type: ")",
          typeable: true,
          base_typeable: true,
          start_col: 1,
          end_col: 2,
          categories: ["parenthesis"],
        },
      ]);

      const result = applyExclusionConfig(line, "minimal");
      expect(result.typing_sequence).toBe("");
    });

    test("token with multiple categories", () => {
      const line = createTestLine([
        {
          text: ":",
          type: ":",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 1,
          categories: ["punctuation", "operator"],
        },
      ]);

      // In minimal mode, punctuation is excluded
      const result = applyExclusionConfig(line, "minimal");
      expect(result.display_tokens[0].typeable).toBe(false);
    });

    test("token with no categories defaults to typeable", () => {
      const line = createTestLine([
        {
          text: "unknown",
          type: "unknown",
          typeable: true,
          base_typeable: true,
          start_col: 0,
          end_col: 7,
          categories: [],
        },
      ]);

      const result = applyExclusionConfig(line, "minimal");
      expect(result.display_tokens[0].typeable).toBe(true);
    });
  });
});

describe("Config: PRESETS", () => {
  test("PRESETS object has correct structure", () => {
    expect(PRESETS).toHaveProperty("minimal");
    expect(PRESETS).toHaveProperty("standard");
    expect(PRESETS).toHaveProperty("full");
  });

  test("minimal preset excludes the most categories", () => {
    expect(PRESETS.minimal.exclude.length).toBeGreaterThan(
      PRESETS.standard.exclude.length
    );
    expect(PRESETS.standard.exclude.length).toBeGreaterThan(
      PRESETS.full.exclude.length
    );
  });

  test("standard preset has includeSpecific array", () => {
    expect(PRESETS.standard.includeSpecific).toBeDefined();
    expect(Array.isArray(PRESETS.standard.includeSpecific)).toBe(true);
  });

  test("includeSpecific overrides exclusions", () => {
    // Standard mode excludes punctuation, but includes specific ones
    expect(PRESETS.standard.exclude).toContain("punctuation");
    expect(PRESETS.standard.includeSpecific).toContain(":");
    expect(PRESETS.standard.includeSpecific).toContain(".");
    expect(PRESETS.standard.includeSpecific).toContain(",");
  });
});