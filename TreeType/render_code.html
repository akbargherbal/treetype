<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tree-Sitter Typing Game - Phase 5.2 Configuration UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Added for smooth scrolling on the root */
      html {
        scroll-behavior: smooth;
      }
      body {
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
      }

      .line {
        line-height: 1.6;
        padding: 2px 0;
        transition: background 0.2s;
      }

      /* Only show hover when test is NOT active */
      body:not(.test-active) .line:hover {
        background: #2a2a2a;
      }

      .line-number {
        user-select: none;
        color: #858585;
        text-align: right;
        padding-right: 16px;
        min-width: 40px;
      }

      /* Syntax highlighting colors (VS Code Dark+ theme) */
      .keyword {
        color: #569cd6;
      }
      .identifier {
        color: #9cdcfe;
      }
      .type_identifier {
        color: #4ec9b0;
      }
      .property_identifier {
        color: #9cdcfe;
      }
      .string_content {
        color: #ce9178;
      }
      .string_start,
      .string_end {
        color: #ce9178;
      }
      .number,
      .integer {
        color: #b5cea8;
      }
      .comment {
        color: #6a9955;
        font-style: italic;
      }
      .operator {
        color: #d4d4d4;
      }
      .punctuation {
        color: #d4d4d4;
      }
      .bracket {
        color: #ffd700;
      }

      .def,
      .function,
      .class,
      .return,
      .if,
      .elif,
      .else,
      .for,
      .while,
      .import,
      .from,
      .as,
      .const,
      .let,
      .var,
      .async,
      .await,
      .interface,
      .type,
      .export {
        color: #c586c0;
      }

      /* PHASE 3.5: Progressive reveal styles */
      .char-untyped {
        color: #858585 !important;
        opacity: 1;
      }

      .char-current {
        background: rgba(255, 255, 0, 0.3);
        border-bottom: 2px solid #fbbf24;
        animation: pulse 1s infinite;
      }

      .char-error {
        color: #ef4444 !important;
        background: rgba(239, 68, 68, 0.4);
        border: 2px solid #ef4444;
        border-radius: 2px;
      }

      @keyframes pulse {
        0%,
        100% {
          border-bottom-color: #fbbf24;
        }
        50% {
          border-bottom-color: #fcd34d;
        }
      }

      /* Active test indicator */
      .test-active-line {
        border-left: 4px solid #10b981;
      }

      /* Distraction-free mode: fade controls during active typing */
      .controls-area {
        transition: opacity 0.3s ease, transform 0.3s ease;
      }

      body.test-active .controls-area {
        opacity: 0.1;
      }

      body.test-active .controls-area:hover {
        opacity: 1;
      }

      /* Center the typing area for better ergonomics */
      #codeDisplay {
        outline: none;
        min-height: 60vh;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        padding-top: 2rem;
        padding-bottom: 2rem;
      }

      #codeDisplay.focused {
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      }

      /* Completion Modal */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        animation: fadeIn 0.3s;
      }

      .modal-content {
        background: #2a2a2a;
        border-radius: 12px;
        padding: 32px;
        max-width: 400px;
        width: 90%;
        text-align: center;
        animation: slideUp 0.3s;
        border: 2px solid #4ade80;
      }

      .modal-title {
        font-size: 2em;
        margin-bottom: 8px;
      }

      .modal-subtitle {
        color: #9ca3af;
        margin-bottom: 24px;
      }

      .modal-stats {
        background: #1e1e1e;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 24px;
      }

      .modal-stat {
        margin: 12px 0;
      }

      .modal-stat-label {
        color: #9ca3af;
        font-size: 0.9em;
      }

      .modal-stat-value {
        font-size: 1.8em;
        font-weight: bold;
        color: #4ade80;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
      }

      .modal-button {
        padding: 12px 24px;
        border-radius: 6px;
        border: none;
        font-size: 1em;
        cursor: pointer;
        transition: all 0.2s;
      }

      .modal-button-primary {
        background: #3b82f6;
        color: white;
      }

      .modal-button-primary:hover {
        background: #2563eb;
      }

      .modal-button-secondary {
        background: #374151;
        color: white;
      }

      .modal-button-secondary:hover {
        background: #4b5563;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body class="p-8">
    <div class="max-w-6xl mx-auto">
      <!-- Header & Controls: Wrapped for fade effect -->
      <div class="controls-area">
        <!-- Header -->
        <div class="mb-8">
          <h1 class="text-3xl font-bold mb-2">Tree-Sitter Typing Game</h1>
          <p class="text-gray-400">
            Phase 5.2: Configuration UI - Customizable Typing Modes
          </p>
        </div>

        <!-- Controls -->
        <div class="mb-6 flex gap-4 items-center flex-wrap">
          <label class="text-gray-300">Language:</label>
          <select
            id="languageSelect"
            class="bg-gray-800 text-white px-4 py-2 rounded border border-gray-600"
          >
            <option value="python">Python</option>
            <option value="javascript">JavaScript</option>
            <option value="typescript">TypeScript</option>
            <option value="tsx">TSX/React</option>
          </select>

          <!-- NEW: Typing Mode Selector -->
          <label class="text-gray-300 ml-6">Typing Mode:</label>
          <div class="flex gap-2">
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="minimal"
                class="cursor-pointer"
              />
              <span class="text-sm">Minimal</span>
            </label>
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="standard"
                checked
                class="cursor-pointer"
              />
              <span class="text-sm">Standard</span>
            </label>
            <label
              class="flex items-center gap-2 cursor-pointer px-3 py-2 bg-gray-800 rounded hover:bg-gray-700 transition"
            >
              <input
                type="radio"
                name="typingMode"
                value="full"
                class="cursor-pointer"
              />
              <span class="text-sm">Full</span>
            </label>
          </div>

          <button
            id="resetBtn"
            class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded ml-auto"
          >
            Reset (Esc)
          </button>

          <div id="testStatus" class="text-sm">
            <span class="text-gray-400">Press any key to start...</span>
          </div>
        </div>

        <!-- Stats Display -->
        <div id="stats" class="mb-6 p-4 bg-gray-800 rounded"></div>
      </div>

      <!-- Code Display -->
      <div
        id="codeDisplay"
        class="bg-gray-900 rounded-lg p-6 overflow-x-auto cursor-text"
        tabindex="0"
      >
        <div id="codeLines"></div>
      </div>

      <!-- Instructions: Also fade during typing -->
      <div class="mt-6 p-4 bg-gray-800 rounded controls-area">
        <h3 class="font-bold mb-2">Instructions:</h3>
        <ul class="text-sm space-y-1 mb-4">
          <li>
            ‚Ä¢ <span class="text-gray-400">Gray text</span> = Not yet typed
          </li>
          <li>
            ‚Ä¢
            <span class="bg-yellow-500 bg-opacity-30 px-1"
              >Yellow highlight</span
            >
            = Current character to type
          </li>
          <li>
            ‚Ä¢ <span style="color: #569cd6">Colored text</span> = Already typed
            (syntax revealed)
          </li>
          <li>
            ‚Ä¢
            <span class="text-red-400 bg-red-900 bg-opacity-20 px-1"
              >Red highlight</span
            >
            = Wrong key (stays until corrected)
          </li>
          <li>
            ‚Ä¢ Press <kbd class="px-2 py-1 bg-gray-700 rounded">Esc</kbd> to
            reset
          </li>
        </ul>

        <h3 class="font-bold mb-2 mt-4">Typing Modes:</h3>
        <ul class="text-sm space-y-1">
          <li>
            ‚Ä¢ <strong>Minimal</strong>: Type only keywords and identifiers
            (fastest)
          </li>
          <li>
            ‚Ä¢ <strong>Standard</strong> ‚≠ê: Type keywords, identifiers,
            operators, and <code>:</code> <code>;</code> (recommended)
          </li>
          <li>
            ‚Ä¢ <strong>Full</strong>: Type everything except whitespace and
            comments (maximum practice)
          </li>
        </ul>
      </div>
    </div>

    <script>
      // =====================================================================
      // PRESET CONFIGURATIONS (PHASE 5.2)
      // =====================================================================

      const PRESETS = {
        minimal: {
          name: "Minimal",
          description: "Type only keywords and identifiers",
          exclude: [
            "bracket",
            "operator",
            "punctuation",
            "string_content",
            "string_delimiter",
            "comment",
          ],
        },
        standard: {
          name: "Standard",
          description: "Balanced typing experience (recommended)",
          exclude: ["bracket", "string_content", "string_delimiter", "comment"],
          // Special handling: include : and ; even though they're in punctuation category
          includeSpecific: [":", ";"],
        },
        full: {
          name: "Full",
          description: "Type everything except whitespace and comments",
          exclude: ["comment", "string_content"],
        },
      };

      // =====================================================================
      // STATE MANAGEMENT
      // =====================================================================

      let currentData = null;
      let rawData = null; // Store original unfiltered data
      let testState = {
        active: false,
        startTime: null,
        endTime: null,
        currentLineIndex: 0,
        currentCharIndex: 0,
        totalCharsTyped: 0,
        totalErrors: 0,
        completedLines: new Set(),
        errorOnCurrentChar: false,
      };

      // =====================================================================
      // APPLY EXCLUSION CONFIG (PHASE 5.2)
      // =====================================================================

      function applyExclusionConfig(lineData, preset) {
        const config = PRESETS[preset];

        // Filter tokens based on preset
        const filteredTokens = lineData.display_tokens.map((token) => {
          let typeable = token.base_typeable;

          // If token has no categories, it's always typeable (keywords, identifiers)
          if (!token.categories || token.categories.length === 0) {
            return { ...token, typeable };
          }

          // Check if token should be specifically included (Standard mode: : and ;)
          if (
            config.includeSpecific &&
            config.includeSpecific.includes(token.text)
          ) {
            return { ...token, typeable: true };
          }

          // Check if any of the token's categories are in the exclusion list
          for (const category of token.categories) {
            if (config.exclude.includes(category)) {
              typeable = false;
              break;
            }
          }

          return { ...token, typeable };
        });

        // Regenerate typing_sequence from typeable tokens
        const typingSequence = filteredTokens
          .filter((t) => t.typeable)
          .map((t) => t.text)
          .join("");

        // Regenerate char_map
        const charMap = {};
        let charIdx = 0;
        const typeableTokens = filteredTokens.filter((t) => t.typeable);

        typeableTokens.forEach((token, tokenIdx) => {
          for (let i = 0; i < token.text.length; i++) {
            charMap[String(charIdx)] = {
              token_idx: tokenIdx,
              display_col: token.start_col,
            };
            charIdx++;
          }
        });

        return {
          ...lineData,
          display_tokens: filteredTokens,
          typing_sequence: typingSequence,
          char_map: charMap,
        };
      }

      // =====================================================================
      // LOAD LANGUAGE DATA (UPDATED FOR PHASE 5.2)
      // =====================================================================

      async function loadLanguage(language) {
        try {
          const response = await fetch(
            `output/json_samples/${language}_sample.json`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          rawData = await response.json();

          // Get current preset
          const preset = document.querySelector(
            'input[name="typingMode"]:checked'
          ).value;

          // Apply filtering to all lines
          currentData = {
            ...rawData,
            lines: rawData.lines.map((line) =>
              applyExclusionConfig(line, preset)
            ),
          };

          resetTest();
        } catch (error) {
          console.error("Error loading file:", error);
          document.getElementById("codeLines").innerHTML = `
                    <div class="text-red-400">
                        Error loading ${language}_sample.json<br>
                        Make sure you're running this from the project root directory.<br>
                        Error: ${error.message}
                    </div>
                `;
        }
      }

      // =====================================================================
      // RESET TEST
      // =====================================================================

      function resetTest() {
        testState = {
          active: false,
          startTime: null,
          endTime: null,
          currentLineIndex: 0,
          currentCharIndex: 0,
          totalCharsTyped: 0,
          totalErrors: 0,
          completedLines: new Set(),
          errorOnCurrentChar: false,
        };

        document.body.classList.remove("test-active");

        renderCode();
        updateStats();
        updateStatus("Press any key to start...");

        // CRITICAL: Use requestAnimationFrame to ensure DOM is fully rendered
        // before calculating scroll position. This prevents the "6 lines of padding" bug
        // when switching languages.
        requestAnimationFrame(() => {
          const firstLine = document.getElementById("line-0");
          if (firstLine) {
            const targetY =
              firstLine.offsetTop -
              window.innerHeight / 4 +
              firstLine.offsetHeight / 4;
            window.scrollTo({
              top: targetY,
              behavior: "auto", // Instant scroll on reset, not smooth
            });
          }
        });
      }

      // =====================================================================
      // RENDER CODE
      // =====================================================================

      function renderCode() {
        if (!currentData) return;

        const display = document.getElementById("codeLines");
        display.innerHTML = "";

        currentData.lines.forEach((lineData, lineIndex) => {
          const lineDiv = document.createElement("div");
          lineDiv.className = "line flex";
          lineDiv.id = `line-${lineIndex}`;
          if (lineIndex === testState.currentLineIndex) {
            lineDiv.classList.add("test-active-line");
          }
          const lineNum = document.createElement("span");
          lineNum.className = "line-number";
          lineNum.textContent = lineData.line_number + 1;
          lineDiv.appendChild(lineNum);
          const contentDiv = document.createElement("div");
          contentDiv.className = "flex-1";
          contentDiv.style.paddingLeft = `${lineData.indent_level * 16}px`;
          contentDiv.id = `line-content-${lineIndex}`;
          renderLineTokens(contentDiv, lineData, lineIndex);
          lineDiv.appendChild(contentDiv);
          display.appendChild(lineDiv);
        });
      }

      // =====================================================================
      // RENDER LINE TOKENS (PHASE 3.5: PROGRESSIVE REVEAL)
      // =====================================================================

      function renderLineTokens(container, lineData, lineIndex) {
        let currentCol = 0;
        let typedCharCount = 0;

        const isCurrentLine = lineIndex === testState.currentLineIndex;
        const isCompletedLine = testState.completedLines.has(lineIndex);
        const isFutureLine = lineIndex > testState.currentLineIndex;

        lineData.display_tokens.forEach((token, tokenIndex) => {
          if (token.start_col > currentCol) {
            const spaces = " ".repeat(token.start_col - currentCol);
            container.appendChild(document.createTextNode(spaces));
          }
          const baseCssClass = getCssClass(token.type, token.text);
          if (token.typeable) {
            for (let i = 0; i < token.text.length; i++) {
              const charSpan = document.createElement("span");
              charSpan.textContent = token.text[i];
              charSpan.className = baseCssClass;
              if (isCompletedLine) {
              } else if (isFutureLine) {
                charSpan.classList.add("char-untyped");
              } else if (isCurrentLine) {
                if (typedCharCount < testState.currentCharIndex) {
                } else if (typedCharCount === testState.currentCharIndex) {
                  if (testState.errorOnCurrentChar) {
                    charSpan.classList.add("char-error");
                  } else {
                    charSpan.classList.add("char-current");
                  }
                  charSpan.classList.add("char-untyped");
                  charSpan.id = "current-char";
                } else {
                  charSpan.classList.add("char-untyped");
                }
              }
              container.appendChild(charSpan);
              typedCharCount++;
            }
          } else {
            const tokenSpan = document.createElement("span");
            tokenSpan.textContent = token.text;
            tokenSpan.className = baseCssClass;

            if (isCompletedLine) {
              // Line complete - show colored
            } else if (isFutureLine) {
              tokenSpan.classList.add("char-untyped");
            } else if (isCurrentLine) {
              // FIX: Use char_map to find current display position
              const currentCharInfo =
                lineData.char_map[String(testState.currentCharIndex)];
              const currentDisplayCol = currentCharInfo?.display_col || 0;

              const tokenStartsAfterCursor =
                token.start_col > currentDisplayCol;

              if (tokenStartsAfterCursor) {
                tokenSpan.classList.add("char-untyped");
              }
            }
            container.appendChild(tokenSpan);
          }
          currentCol = token.end_col;
        });
      }

      // =====================================================================
      // UPDATE STATS DISPLAY
      // =====================================================================

      function updateStats() {
        if (!currentData) return;
        const currentLine = currentData.lines[testState.currentLineIndex];
        const progress = currentLine
          ? `${testState.currentCharIndex}/${currentLine.typing_sequence.length}`
          : "0/0";
        let wpm = 0;
        let accuracy = 100;
        if (testState.active && testState.startTime) {
          const elapsed = (Date.now() - testState.startTime) / 1000 / 60;
          if (elapsed > 0) {
            wpm = Math.round(testState.totalCharsTyped / 5 / elapsed);
          }
        }
        if (testState.totalCharsTyped > 0) {
          accuracy = Math.round(
            ((testState.totalCharsTyped - testState.totalErrors) /
              testState.totalCharsTyped) *
              100
          );
        }

        // Get current preset name
        const preset = document.querySelector(
          'input[name="typingMode"]:checked'
        ).value;
        const presetName = PRESETS[preset].name;

        document.getElementById("stats").innerHTML = `
                <div class="grid grid-cols-6 gap-4 text-sm">
                    <div><div class="text-gray-400">Language</div><div class="font-bold">${
                      currentData.language
                    }</div></div>
                    <div><div class="text-gray-400">Mode</div><div class="font-bold">${presetName}</div></div>
                    <div><div class="text-gray-400">Line Progress</div><div class="font-bold">${
                      testState.currentLineIndex + 1
                    }/${currentData.total_lines}</div></div>
                    <div><div class="text-gray-400">Char Progress</div><div class="font-bold">${progress}</div></div>
                    <div><div class="text-gray-400">WPM</div><div class="font-bold">${wpm}</div></div>
                    <div><div class="text-gray-400">Accuracy</div><div class="font-bold ${
                      accuracy < 95 ? "text-yellow-400" : "text-green-400"
                    }">${accuracy}%</div></div>
                </div>`;
      }

      // =====================================================================
      // UPDATE STATUS MESSAGE
      // =====================================================================

      function updateStatus(message, type = "info") {
        const statusEl = document.getElementById("testStatus");
        const colors = {
          info: "text-gray-400",
          success: "text-green-400",
          error: "text-red-400",
          warning: "text-yellow-400",
        };
        statusEl.innerHTML = `<span class="${colors[type]}">${message}</span>`;
      }

      // =====================================================================
      // KEYBOARD INPUT HANDLER (PHASE 3.5: PERSISTENT ERROR STATE)
      // =====================================================================

      function handleKeyPress(event) {
        if (event.ctrlKey || event.metaKey || event.altKey) return;
        if (event.key === "Escape") {
          event.preventDefault();
          resetTest();
          return;
        }
        if (event.key.length > 1 && event.key !== "Enter" && event.key !== " ")
          return;
        event.preventDefault();
        if (!currentData) return;

        if (!testState.active) {
          testState.active = true;
          testState.startTime = Date.now();
          updateStatus("Typing...", "success");
          document.body.classList.add("test-active");
        }

        const currentLine = currentData.lines[testState.currentLineIndex];
        if (!currentLine) return;
        const expectedChar =
          currentLine.typing_sequence[testState.currentCharIndex];
        const typedKey = event.key;

        if (typedKey === expectedChar) {
          testState.currentCharIndex++;
          testState.totalCharsTyped++;
          testState.errorOnCurrentChar = false;
          updateDisplay();
          if (
            testState.currentCharIndex >= currentLine.typing_sequence.length
          ) {
            setTimeout(() => {
              moveToNextLine();
            }, 50);
          }
        } else {
          testState.totalErrors++;
          testState.errorOnCurrentChar = true;
          updateDisplay();
          updateStats();
        }
      }

      // =====================================================================
      // MOVE TO NEXT LINE
      // =====================================================================

      function moveToNextLine() {
        testState.completedLines.add(testState.currentLineIndex);
        testState.currentLineIndex++;
        testState.currentCharIndex = 0;
        testState.errorOnCurrentChar = false;
        while (testState.currentLineIndex < currentData.total_lines) {
          const nextLine = currentData.lines[testState.currentLineIndex];
          if (
            nextLine &&
            nextLine.typing_sequence &&
            nextLine.typing_sequence.length > 0
          ) {
            break;
          }
          testState.completedLines.add(testState.currentLineIndex);
          testState.currentLineIndex++;
        }
        if (testState.currentLineIndex >= currentData.total_lines) {
          completeTest();
        } else {
          renderCode();
          updateStats();
          setTimeout(manualSmartScroll, 0);
        }
      }

      // =====================================================================
      // MANUAL SMART SCROLL LOGIC
      // =====================================================================
      function manualSmartScroll() {
        const nextLineEl = document.getElementById(
          `line-${testState.currentLineIndex}`
        );
        if (!nextLineEl) return;

        const currentScrollY = window.scrollY;
        const viewportHeight = window.innerHeight;

        const targetY =
          nextLineEl.offsetTop -
          viewportHeight / 4 +
          nextLineEl.offsetHeight / 4;

        if (targetY > currentScrollY) {
          window.scrollTo({
            top: targetY,
          });
        }
      }

      // =====================================================================
      // UPDATE DISPLAY
      // =====================================================================

      function updateDisplay() {
        const currentLine = currentData.lines[testState.currentLineIndex];
        const contentDiv = document.getElementById(
          `line-content-${testState.currentLineIndex}`
        );
        if (contentDiv && currentLine) {
          contentDiv.innerHTML = "";
          renderLineTokens(contentDiv, currentLine, testState.currentLineIndex);
        }
        document.querySelectorAll(".line").forEach((line, idx) => {
          if (idx === testState.currentLineIndex) {
            line.classList.add("test-active-line");
          } else {
            line.classList.remove("test-active-line");
          }
        });
        updateStats();
      }

      // =====================================================================
      // COMPLETE TEST
      // =====================================================================

      function completeTest() {
        testState.active = false;
        testState.endTime = Date.now();
        document.body.classList.remove("test-active");
        const elapsed = (testState.endTime - testState.startTime) / 1000;
        const minutes = Math.floor(elapsed / 60);
        const seconds = Math.floor(elapsed % 60);
        const timeStr = `${minutes}:${seconds.toString().padStart(2, "0")}`;
        const wpm = Math.round(testState.totalCharsTyped / 5 / (elapsed / 60));
        const accuracy = Math.round(
          ((testState.totalCharsTyped - testState.totalErrors) /
            testState.totalCharsTyped) *
            100
        );
        showCompletionModal(wpm, accuracy, timeStr);
        updateStats();
      }

      // =====================================================================
      // SHOW COMPLETION MODAL
      // =====================================================================

      function showCompletionModal(wpm, accuracy, timeStr) {
        const overlay = document.createElement("div");
        overlay.className = "modal-overlay";
        overlay.id = "completionModal";
        overlay.innerHTML = `
          <div class="modal-content">
            <div class="modal-title">üéâ Test Complete!</div>
            <div class="modal-subtitle">Great job on completing the test</div>
            <div class="modal-stats">
              <div class="modal-stat"><div class="modal-stat-label">Words Per Minute</div><div class="modal-stat-value">${wpm}</div></div>
              <div class="modal-stat"><div class="modal-stat-label">Accuracy</div><div class="modal-stat-value">${accuracy}%</div></div>
              <div class="modal-stat"><div class="modal-stat-label">Time</div><div class="modal-stat-value">${timeStr}</div></div>
            </div>
            <div class="modal-buttons">
              <button class="modal-button modal-button-primary" onclick="retryTest()">Retry Test</button>
              <button class="modal-button modal-button-secondary" onclick="closeModal()">Change Language</button>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) closeModal();
        });
      }

      // =====================================================================
      // MODAL ACTIONS
      // =====================================================================

      function closeModal() {
        const modal = document.getElementById("completionModal");
        if (modal) modal.remove();
      }

      function retryTest() {
        closeModal();
        resetTest();
      }

      // =====================================================================
      // CSS CLASS HELPER
      // =====================================================================

      function getCssClass(type, text) {
        if (["(", ")", "[", "]", "{", "}", "<", ">"].includes(type))
          return "bracket";
        const keywords = [
          "def",
          "function",
          "class",
          "return",
          "if",
          "elif",
          "else",
          "for",
          "while",
          "import",
          "from",
          "as",
          "const",
          "let",
          "var",
          "async",
          "await",
          "interface",
          "type",
          "export",
          "default",
        ];
        if (keywords.includes(type)) return type;
        if (type.includes("comment")) return "comment";
        if (type.includes("string")) return type.replace(/_/g, "_");
        if (type === "integer" || type === "number" || type === "float")
          return "number";
        if (type.includes("identifier")) return type;
        if (
          ["->", "=>", "=", "+", "-", "*", "/", "%", "++", "--"].includes(type)
        )
          return "operator";
        if ([":", ";", ",", "."].includes(type)) return "punctuation";
        return type.replace(/[^a-zA-Z0-9_]/g, "_");
      }

      // =====================================================================
      // CONFIGURATION & PERSISTENCE (PHASE 5.2)
      // =====================================================================

      const DEFAULT_CONFIG = {
        preset: "standard",
        language: "python",
      };

      function saveConfig() {
        const config = {
          preset: document.querySelector('input[name="typingMode"]:checked')
            .value,
          language: document.getElementById("languageSelect").value,
        };
        localStorage.setItem("treetype_config", JSON.stringify(config));
      }

      function loadConfig() {
        const saved = localStorage.getItem("treetype_config");
        return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
      }

      // =====================================================================
      // EVENT LISTENERS (UPDATED FOR PHASE 5.2)
      // =====================================================================

      document
        .getElementById("languageSelect")
        .addEventListener("change", (e) => {
          loadLanguage(e.target.value);
          saveConfig();
        });

      // NEW: Add event listener for preset changes
      document.querySelectorAll('input[name="typingMode"]').forEach((radio) => {
        radio.addEventListener("change", () => {
          if (rawData) {
            const preset = document.querySelector(
              'input[name="typingMode"]:checked'
            ).value;

            // Reapply filtering to all lines
            currentData = {
              ...rawData,
              lines: rawData.lines.map((line) =>
                applyExclusionConfig(line, preset)
              ),
            };

            resetTest();
            saveConfig();
          }
        });
      });

      document.getElementById("resetBtn").addEventListener("click", () => {
        resetTest();
      });
      document.getElementById("codeDisplay").addEventListener("click", () => {
        document.getElementById("codeDisplay").classList.add("focused");
      });
      document.getElementById("codeDisplay").addEventListener("blur", () => {
        document.getElementById("codeDisplay").classList.remove("focused");
      });
      document.addEventListener("keydown", handleKeyPress);

      // NEW: Load saved config on page load
      document.addEventListener("DOMContentLoaded", () => {
        const config = loadConfig();

        // Set preset
        const presetRadio = document.querySelector(
          `input[name="typingMode"][value="${config.preset}"]`
        );
        if (presetRadio) {
          presetRadio.checked = true;
        }

        // Set language
        document.getElementById("languageSelect").value = config.language;

        // Load language with saved config
        loadLanguage(config.language);
        document.getElementById("codeDisplay").focus();
      });
    </script>
  </body>
</html>
