<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tree-Sitter Typing Game - Phase 2.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
      }

      .line {
        line-height: 1.6;
        padding: 2px 0;
      }

      .line:hover {
        background: #2a2a2a;
      }

      .line-number {
        user-select: none;
        color: #858585;
        text-align: right;
        padding-right: 16px;
        min-width: 40px;
      }

      /* Syntax highlighting colors (VS Code Dark+ theme) */
      .keyword {
        color: #569cd6;
      }
      .identifier {
        color: #9cdcfe;
      }
      .type_identifier {
        color: #4ec9b0;
      }
      .property_identifier {
        color: #9cdcfe;
      }
      .string_content {
        color: #ce9178;
      }
      .string_start,
      .string_end {
        color: #ce9178;
      }
      .number,
      .integer {
        color: #b5cea8;
      }
      .comment {
        color: #6a9955;
        font-style: italic;
      }
      .operator {
        color: #d4d4d4;
      }
      .punctuation {
        color: #d4d4d4;
      }
      .bracket {
        color: #ffd700;
      }

      .def,
      .function,
      .class,
      .return,
      .if,
      .elif,
      .else,
      .for,
      .while,
      .import,
      .from,
      .as,
      .const,
      .let,
      .var,
      .async,
      .await,
      .interface,
      .type,
      .export {
        color: #c586c0;
      }

      .non-typeable {
        opacity: 0.6;
      }

      /* PHASE 2: Typing feedback styles */
      .char-correct {
        color: #4ade80 !important;
        opacity: 1 !important;
      }

      .char-current {
        background: rgba(255, 255, 0, 0.3);
        border-bottom: 2px solid #fbbf24;
        animation: pulse 1s infinite;
      }

      .char-error {
        color: #ef4444 !important;
        animation: shake 0.3s;
      }

      @keyframes pulse {
        0%,
        100% {
          border-bottom-color: #fbbf24;
        }
        50% {
          border-bottom-color: #fcd34d;
        }
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-2px);
        }
        75% {
          transform: translateX(2px);
        }
      }

      /* Focus indicator for code area */
      #codeDisplay {
        outline: none;
      }

      #codeDisplay.focused {
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      }

      /* Active test indicator */
      .test-active {
        border-left: 4px solid #10b981;
      }
    </style>
  </head>
  <body class="p-8">
    <div class="max-w-6xl mx-auto">
      <!-- Header -->
      <div class="mb-8">
        <h1 class="text-3xl font-bold mb-2">Tree-Sitter Typing Game</h1>
        <p class="text-gray-400">
          Phase 2.2: Typing Input Handler with Visual Feedback
        </p>
      </div>

      <!-- Controls -->
      <div class="mb-6 flex gap-4 items-center">
        <label class="text-gray-300">Language:</label>
        <select
          id="languageSelect"
          class="bg-gray-800 text-white px-4 py-2 rounded border border-gray-600"
        >
          <option value="python">Python</option>
          <option value="javascript">JavaScript</option>
          <option value="typescript">TypeScript</option>
          <option value="tsx">TSX/React</option>
        </select>

        <button
          id="resetBtn"
          class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded"
        >
          Reset (Esc)
        </button>

        <div id="testStatus" class="ml-auto text-sm">
          <span class="text-gray-400">Press any key to start...</span>
        </div>
      </div>

      <!-- Stats Display -->
      <div id="stats" class="mb-6 p-4 bg-gray-800 rounded"></div>

      <!-- Code Display -->
      <div
        id="codeDisplay"
        class="bg-gray-900 rounded-lg p-6 overflow-x-auto cursor-text"
        tabindex="0"
      >
        <div id="codeLines"></div>
      </div>

      <!-- Instructions -->
      <div class="mt-6 p-4 bg-gray-800 rounded">
        <h3 class="font-bold mb-2">Instructions:</h3>
        <ul class="text-sm space-y-1">
          <li>
            • <span class="text-green-400">Green text</span> = Already typed
            correctly
          </li>
          <li>
            •
            <span class="bg-yellow-500 bg-opacity-30 px-1"
              >Yellow highlight</span
            >
            = Current character to type
          </li>
          <li>
            • <span class="text-gray-400">Dimmed text</span> = Non-typeable
            (will be skipped automatically)
          </li>
          <li>
            • <span class="text-red-400">Red flash</span> = Wrong key pressed
          </li>
          <li>
            • Type only the <strong>highlighted characters</strong> -
            punctuation and brackets are skipped
          </li>
          <li>
            • Press <kbd class="px-2 py-1 bg-gray-700 rounded">Esc</kbd> to
            reset
          </li>
        </ul>
      </div>
    </div>

    <script>
      // =====================================================================
      // STATE MANAGEMENT
      // =====================================================================

      let currentData = null;
      let testState = {
        active: false,
        startTime: null,
        endTime: null,
        currentLineIndex: 0,
        currentCharIndex: 0,
        totalCharsTyped: 0,
        totalErrors: 0,
      };

      // =====================================================================
      // LOAD LANGUAGE DATA
      // =====================================================================

      async function loadLanguage(language) {
        try {
          const response = await fetch(
            `output/json_samples/${language}_sample.json`
          );
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          currentData = await response.json();
          resetTest();
        } catch (error) {
          console.error("Error loading file:", error);
          document.getElementById("codeLines").innerHTML = `
                    <div class="text-red-400">
                        Error loading ${language}_sample.json<br>
                        Make sure you're running this from the project root directory.<br>
                        Error: ${error.message}
                    </div>
                `;
        }
      }

      // =====================================================================
      // RESET TEST
      // =====================================================================

      function resetTest() {
        testState = {
          active: false,
          startTime: null,
          endTime: null,
          currentLineIndex: 0,
          currentCharIndex: 0,
          totalCharsTyped: 0,
          totalErrors: 0,
        };

        renderCode();
        updateStats();
        updateStatus("Press any key to start...");
      }

      // =====================================================================
      // RENDER CODE
      // =====================================================================

      function renderCode() {
        if (!currentData) return;

        const display = document.getElementById("codeLines");
        display.innerHTML = "";

        // Render each line
        currentData.lines.forEach((lineData, lineIndex) => {
          const lineDiv = document.createElement("div");
          lineDiv.className = "line flex";
          lineDiv.id = `line-${lineIndex}`;

          // Highlight current line
          if (lineIndex === testState.currentLineIndex) {
            lineDiv.classList.add("test-active");
          }

          // Line number
          const lineNum = document.createElement("span");
          lineNum.className = "line-number";
          lineNum.textContent = lineData.line_number + 1;
          lineDiv.appendChild(lineNum);

          // Line content container with indentation
          const contentDiv = document.createElement("div");
          contentDiv.className = "flex-1";
          contentDiv.style.paddingLeft = `${lineData.indent_level * 16}px`;
          contentDiv.id = `line-content-${lineIndex}`;

          // Render tokens
          renderLineTokens(contentDiv, lineData, lineIndex);

          lineDiv.appendChild(contentDiv);
          display.appendChild(lineDiv);
        });
      }

      // =====================================================================
      // RENDER LINE TOKENS
      // =====================================================================

      function renderLineTokens(container, lineData, lineIndex) {
        let currentCol = 0;
        let typedCharCount = 0;

        const isCurrentLine = lineIndex === testState.currentLineIndex;

        lineData.display_tokens.forEach((token, tokenIndex) => {
          // Add spaces to reach token's start column
          if (token.start_col > currentCol) {
            const spaces = " ".repeat(token.start_col - currentCol);
            container.appendChild(document.createTextNode(spaces));
          }

          // For typeable tokens on current line, render character-by-character
          if (isCurrentLine && token.typeable) {
            for (let i = 0; i < token.text.length; i++) {
              const charSpan = document.createElement("span");
              charSpan.textContent = token.text[i];

              // Apply base styling
              const cssClass = getCssClass(token.type, token.text);
              charSpan.className = cssClass;

              // Apply typing feedback
              if (typedCharCount < testState.currentCharIndex) {
                // Already typed
                charSpan.classList.add("char-correct");
              } else if (typedCharCount === testState.currentCharIndex) {
                // Current character
                charSpan.classList.add("char-current");
                charSpan.id = "current-char";
              }
              // else: not yet typed (keep default styling)

              container.appendChild(charSpan);
              typedCharCount++;
            }
          } else {
            // Non-typeable or not current line - render as single span
            const tokenSpan = document.createElement("span");
            tokenSpan.textContent = token.text;

            const cssClass = getCssClass(token.type, token.text);
            tokenSpan.className = cssClass;

            if (!token.typeable) {
              tokenSpan.className += " non-typeable";
            }

            container.appendChild(tokenSpan);
          }

          currentCol = token.end_col;
        });
      }

      // =====================================================================
      // UPDATE STATS DISPLAY
      // =====================================================================

      function updateStats() {
        if (!currentData) return;

        const currentLine = currentData.lines[testState.currentLineIndex];
        const progress = currentLine
          ? `${testState.currentCharIndex}/${currentLine.typing_sequence.length}`
          : "0/0";

        let wpm = 0;
        let accuracy = 100;

        if (testState.active && testState.startTime) {
          const elapsed = (Date.now() - testState.startTime) / 1000 / 60; // minutes
          if (elapsed > 0) {
            wpm = Math.round(testState.totalCharsTyped / 5 / elapsed);
          }
        }

        if (testState.totalCharsTyped > 0) {
          accuracy = Math.round(
            ((testState.totalCharsTyped - testState.totalErrors) /
              testState.totalCharsTyped) *
              100
          );
        }

        document.getElementById("stats").innerHTML = `
                <div class="grid grid-cols-5 gap-4 text-sm">
                    <div>
                        <div class="text-gray-400">Language</div>
                        <div class="font-bold">${currentData.language}</div>
                    </div>
                    <div>
                        <div class="text-gray-400">Line Progress</div>
                        <div class="font-bold">${
                          testState.currentLineIndex + 1
                        }/${currentData.total_lines}</div>
                    </div>
                    <div>
                        <div class="text-gray-400">Char Progress</div>
                        <div class="font-bold">${progress}</div>
                    </div>
                    <div>
                        <div class="text-gray-400">WPM</div>
                        <div class="font-bold">${wpm}</div>
                    </div>
                    <div>
                        <div class="text-gray-400">Accuracy</div>
                        <div class="font-bold ${
                          accuracy < 95 ? "text-yellow-400" : "text-green-400"
                        }">${accuracy}%</div>
                    </div>
                </div>
            `;
      }

      // =====================================================================
      // UPDATE STATUS MESSAGE
      // =====================================================================

      function updateStatus(message, type = "info") {
        const statusEl = document.getElementById("testStatus");
        const colors = {
          info: "text-gray-400",
          success: "text-green-400",
          error: "text-red-400",
          warning: "text-yellow-400",
        };
        statusEl.innerHTML = `<span class="${colors[type]}">${message}</span>`;
      }

      // =====================================================================
      // KEYBOARD INPUT HANDLER
      // =====================================================================

      function handleKeyPress(event) {
        // Allow browser shortcuts with modifiers
        if (event.ctrlKey || event.metaKey || event.altKey) {
          return;
        }

        // Handle Escape
        if (event.key === "Escape") {
          event.preventDefault();
          resetTest();
          return;
        }

        // Ignore special keys that aren't Escape
        if (
          event.key.length > 1 &&
          event.key !== "Enter" &&
          event.key !== " "
        ) {
          return;
        }

        event.preventDefault();

        if (!currentData) return;

        // Start test on first keystroke
        if (!testState.active) {
          testState.active = true;
          testState.startTime = Date.now();
          updateStatus("Typing...", "success");
        }

        const currentLine = currentData.lines[testState.currentLineIndex];
        if (!currentLine) return;

        const expectedChar =
          currentLine.typing_sequence[testState.currentCharIndex];
        const typedKey = event.key;

        // Check if key matches
        if (typedKey === expectedChar) {
          // Correct key!
          testState.currentCharIndex++;
          testState.totalCharsTyped++;

          // Check if line is complete
          if (
            testState.currentCharIndex >= currentLine.typing_sequence.length
          ) {
            moveToNextLine();
          } else {
            updateDisplay();
          }
        } else {
          // Wrong key - flash error
          testState.totalErrors++;
          flashError();
          updateStats();
        }
      }

      // =====================================================================
      // MOVE TO NEXT LINE
      // =====================================================================

      function moveToNextLine() {
        // Clean up old cursor before moving
        const oldCursor = document.getElementById("current-char");
        if (oldCursor) {
          oldCursor.removeAttribute("id");
          oldCursor.classList.remove("char-current");
        }

        testState.currentLineIndex++;
        testState.currentCharIndex = 0;

        // Skip lines with empty typing sequences (comments, docstrings, etc.)
        while (testState.currentLineIndex < currentData.total_lines) {
          const nextLine = currentData.lines[testState.currentLineIndex];

          if (
            nextLine &&
            nextLine.typing_sequence &&
            nextLine.typing_sequence.length > 0
          ) {
            // Found a line with typeable content
            break;
          }

          // This line is empty/non-typeable, skip to next
          testState.currentLineIndex++;
        }

        // Check if test is complete
        if (testState.currentLineIndex >= currentData.total_lines) {
          completeTest();
        } else {
          updateDisplay();
        }
      }

      // =====================================================================
      // UPDATE DISPLAY (after correct key)
      // =====================================================================

      function updateDisplay() {
        // AGGRESSIVE CLEANUP: Remove all cursor indicators
        document.querySelectorAll(".char-current").forEach((el) => {
          el.classList.remove("char-current");
          if (el.id === "current-char") {
            el.removeAttribute("id");
          }
        });

        // Re-render current line
        const currentLine = currentData.lines[testState.currentLineIndex];
        const contentDiv = document.getElementById(
          `line-content-${testState.currentLineIndex}`
        );

        if (contentDiv && currentLine) {
          contentDiv.innerHTML = "";
          renderLineTokens(contentDiv, currentLine, testState.currentLineIndex);
        }

        // Update active line indicator
        document.querySelectorAll(".line").forEach((line, idx) => {
          if (idx === testState.currentLineIndex) {
            line.classList.add("test-active");
          } else {
            line.classList.remove("test-active");
          }
        });

        updateStats();

        // Scroll current character into view
        const currentChar = document.getElementById("current-char");
        if (currentChar) {
          currentChar.scrollIntoView({ behavior: "smooth", block: "center" });
        }
      }

      // =====================================================================
      // FLASH ERROR (wrong key)
      // =====================================================================

      function flashError() {
        const currentChar = document.getElementById("current-char");
        if (currentChar) {
          currentChar.classList.add("char-error");
          setTimeout(() => {
            currentChar.classList.remove("char-error");
          }, 300);
        }
      }

      // =====================================================================
      // COMPLETE TEST
      // =====================================================================

      function completeTest() {
        testState.active = false;
        testState.endTime = Date.now();

        const elapsed = (testState.endTime - testState.startTime) / 1000;
        const wpm = Math.round(testState.totalCharsTyped / 5 / (elapsed / 60));
        const accuracy = Math.round(
          ((testState.totalCharsTyped - testState.totalErrors) /
            testState.totalCharsTyped) *
            100
        );

        updateStatus(
          `Complete! ${wpm} WPM, ${accuracy}% accuracy. Press Esc to try again.`,
          "success"
        );

        updateStats();
      }

      // =====================================================================
      // CSS CLASS HELPER
      // =====================================================================

      function getCssClass(type, text) {
        if (["(", ")", "[", "]", "{", "}", "<", ">"].includes(type)) {
          return "bracket";
        }

        const keywords = [
          "def",
          "function",
          "class",
          "return",
          "if",
          "elif",
          "else",
          "for",
          "while",
          "import",
          "from",
          "as",
          "const",
          "let",
          "var",
          "async",
          "await",
          "interface",
          "type",
          "export",
          "default",
        ];
        if (keywords.includes(type)) {
          return type;
        }

        if (type.includes("comment")) {
          return "comment";
        }

        if (type.includes("string")) {
          return type.replace(/_/g, "_");
        }

        if (type === "integer" || type === "number" || type === "float") {
          return "number";
        }

        if (type.includes("identifier")) {
          return type;
        }

        if (
          ["->", "=>", "=", "+", "-", "*", "/", "%", "++", "--"].includes(type)
        ) {
          return "operator";
        }

        if ([":", ";", ",", "."].includes(type)) {
          return "punctuation";
        }

        return type.replace(/[^a-zA-Z0-9_]/g, "_");
      }

      // =====================================================================
      // EVENT LISTENERS
      // =====================================================================

      document
        .getElementById("languageSelect")
        .addEventListener("change", (e) => {
          loadLanguage(e.target.value);
        });

      document.getElementById("resetBtn").addEventListener("click", () => {
        resetTest();
      });

      document.getElementById("codeDisplay").addEventListener("click", () => {
        document.getElementById("codeDisplay").classList.add("focused");
      });

      document.getElementById("codeDisplay").addEventListener("blur", () => {
        document.getElementById("codeDisplay").classList.remove("focused");
      });

      // Global keydown listener
      document.addEventListener("keydown", handleKeyPress);

      // Initial load
      document.addEventListener("DOMContentLoaded", () => {
        loadLanguage("python");
        document.getElementById("codeDisplay").focus();
      });
    </script>
  </body>
</html>
