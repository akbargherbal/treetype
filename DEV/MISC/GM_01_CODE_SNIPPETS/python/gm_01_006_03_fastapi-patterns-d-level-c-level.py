# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def read_root() -> dict:
    return {"message": "Welcome to FastAPI!"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI

app = FastAPI()

@app.get("/items/{item_id}")
async def read_item(item_id: int) -> dict:
    return {"item_id": item_id, "description": f"Item number {item_id}"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from typing import Optional
from fastapi import FastAPI

app = FastAPI()

@app.get("/products/")
async def read_products(limit: int = 10, search: Optional[str] = None) -> dict:
    results = {"limit": limit}
    if search:
        results["search"] = search
    return results

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from pydantic import BaseModel

class Product(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Product(BaseModel):
    name: str
    description: Optional[str] = None
    price: float

@app.post("/products/")
async def create_product(product: Product) -> Product:
    return product

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class ProductIn(BaseModel):
    name: str
    price: float

class ProductOut(BaseModel):
    product_id: int
    name: str
    price: float

@app.post("/products/", response_model=ProductOut)
async def create_product(product: ProductIn) -> ProductOut:
    # In a real app, product_id would be generated by a DB
    return ProductOut(product_id=123, name=product.name, price=product.price)

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, status
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str

@app.post("/items/", status_code=status.HTTP_201_CREATED)
async def create_item(item: Item) -> Item:
    return item

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, Depends

app = FastAPI()

def get_current_user() -> str:
    # In a real app, this would validate a token and return user data
    return "john.doe"

@app.get("/users/me")
async def read_current_user(current_user: str = Depends(get_current_user)) -> dict:
    return {"username": current_user}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, HTTPException

app = FastAPI()

items_db = {"foo": "The Foo Wrestlers", "bar": "The Bar Fighters"}

@app.get("/items/{item_id}")
async def read_item(item_id: str) -> dict:
    if item_id not in items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items_db[item_id]}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI
import asyncio

app = FastAPI()

@app.get("/long-process/{task_id}")
async def perform_long_process(task_id: int) -> dict:
    await asyncio.sleep(2) # Simulate an I/O bound operation
    return {"task_id": task_id, "status": "completed"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, BackgroundTasks

app = FastAPI()

def write_log(message: str):
    with open("app.log", mode="a") as log:
        log.write(message + "\n")

@app.post("/send-notification/")
async def send_notification(
    email: str,
    background_tasks: BackgroundTasks
) -> dict:
    background_tasks.add_task(write_log, f"Notification sent to {email}")
    return {"message": "Notification scheduled"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, APIRouter

app = FastAPI()
router = APIRouter(prefix="/users", tags=["users"])

@router.get("/")
async def read_users() -> list[dict]:
    return [{"username": "Alice"}, {"username": "Bob"}]

@router.get("/{user_id}")
async def read_user(user_id: int) -> dict:
    return {"user_id": user_id, "username": f"User {user_id}"}

app.include_router(router)

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

origins = [
    "http://localhost",
    "http://localhost:8080",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def read_root() -> dict:
    return {"message": "CORS enabled"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login/")
async def login(username: str = Form(...), password: str = Form(...)) -> dict:
    # In a real app, you'd validate credentials
    if username == "test" and password == "secret":
        return {"message": "Login successful!"}
    return {"message": "Invalid credentials"}

# PATTERN: FastAPI Patterns (D-Level → C-Level)

from fastapi import FastAPI, UploadFile, File
import shutil

app = FastAPI()

@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile = File(...)) -> dict:
    with open(f"uploaded_{file.filename}", "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    return {"filename": file.filename, "content_type": file.content_type}